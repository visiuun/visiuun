<!doctype html>
<html lang="it">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>UDA 19 - Ciclo Vita Software [Presentazione]</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reset.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/dracula.min.css" id="theme">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">

    <style>
        .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
            text-transform: none;
            margin-bottom: 25px;
            word-wrap: break-word; /* Per evitare overflow orizzontale */
        }
        .reveal section ul, .reveal section ol {
            margin-bottom: 20px;
        }
         .reveal section li {
            margin-bottom: 12px;
            line-height: 1.45;
        }
        .reveal blockquote {
            font-style: italic;
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-left: 5px solid #ff79c6;
            margin: 20px 0;
        }
        .reveal pre code {
          font-size: 0.85em;
          max-height: 350px;
          border-radius: 5px;
          padding: 10px !important; /* Aumenta padding interno */
        }
        .smaller-text {
            font-size: 0.8em;
            margin-top: 15px;
        }
        strong {
            color: #50fa7b; /* Verde acceso */
        }
        /* Stili per le note dell'oratore */
        .reveal .notes {
            font-size: 16px;
            line-height: 1.5;
            color: #eee; /* Colore più leggibile per le note */
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">

            <section data-transition="zoom">
                <small>UDA 19</small>
                <h1>Ciclo di Vita e Modelli di Sviluppo del Software</h1>
                <p>Test, Valutazione e Stima dei Costi</p>
                <hr>
                <ul>
                    <li class="fragment fade-up">Il Collaudo del Software (<strong>Testing</strong>)</li>
                    <li class="fragment fade-up">Valutazione e Stima dei Costi (<strong>Metriche</strong> Software)</li>
                </ul>
                <aside class="notes">
                    Benvenuti a questa presentazione sull'Unità Didattica 19. Oggi esploreremo due aspetti fondamentali dello sviluppo software: come ci assicuriamo che funzioni correttamente (Testing) e come ne misuriamo le caratteristiche e stimiamo i costi (Metriche).
                </aside>
            </section>

            <section data-transition="slide-in fade-out">
                <h2>Introduzione - Perché Testare e Misurare?</h2>
                <ul>
                    <li class="fragment fade-left">Software sempre più <strong>complesso</strong> e <strong>critico</strong>.</li>
                    <li class="fragment fade-left">Identificare problemi presto = <strong>riduzione costi e rischi</strong>.</li>
                    <li class="fragment fade-left">Comprendere "dimensione" e "qualità" = <strong>gestione efficace</strong>.</li>
                </ul>
                <blockquote cite="Tom De Marco" class="fragment grow">
                    "Non puoi controllare ciò che non sai misurare"
                    <footer><cite>- Tom De Marco</cite></footer>
                </blockquote>
                 <aside class="notes">
                    Viviamo in un mondo guidato dal software. Dalle app bancarie ai sistemi medicali, la complessità aumenta. Errori possono avere conseguenze gravi.
                    Testare significa trovare questi errori prima che causino danni. Misurare ci dà i numeri per capire dove siamo e dove stiamo andando.
                    Come dice De Marco, senza misure, navighiamo alla cieca nel progetto.
                </aside>
            </section>

            <section data-transition="zoom-in fade-out">
                 <h2>19.4 Metodologie di Test - Cos'è il <strong>Collaudo</strong>?</h2>
                 <p class="fragment fade-up"><strong>Definizione:</strong> Processo per trovare mancanze di:</p>
                 <ul>
                     <li class="fragment highlight-current-blue"><strong>Correttezza</strong> (fa le cose giuste?)</li>
                     <li class="fragment highlight-current-blue"><strong>Completezza</strong> (fa tutte le cose richieste?)</li>
                     <li class="fragment highlight-current-blue"><strong>Affidabilità</strong> (lo fa bene nel tempo?)</li>
                 </ul>
                 <p class="fragment fade-up"><strong>Scopo:</strong> Rilevare <strong>difetti</strong> osservando <strong>malfunzionamenti</strong>.</p>
                 <p class="fragment fade-up"><strong>Tendenza:</strong> Integrazione con lo sviluppo (es. <strong>TDD</strong> - Test Driven Development).</p>
                 <aside class="notes">
                     Quindi, cos'è il testing o collaudo? Non è dimostrare che il software è perfetto (impossibile!), ma è un'indagine sistematica per scovare problemi.
                     Cerchiamo deviazioni rispetto a ciò che ci aspettiamo (correttezza, completezza, affidabilità).
                     Lo scopo primario è far emergere i bug nascosti provocando malfunzionamenti.
                     Oggi non si testa solo alla fine, ma durante tutto lo sviluppo, come nel TDD, dove i test guidano la scrittura del codice.
                 </aside>
            </section>

            <section>
                <h2>Malfunzionamenti vs. Difetti: <strong>Causa ed Effetto</strong></h2>
                <ul>
                    <li class="fragment fade-right"><strong>Malfunzionamento:</strong> Comportamento errato osservato. (Il <em>sintomo</em>)</li>
                    <li class="fragment fade-right"><strong>Difetto (Bug):</strong> Errore nel codice/design che causa il malfunzionamento. (La <em>causa</em>)</li>
                </ul>
                <p class="fragment grow">Il collaudo usa input specifici per <strong>attivare i difetti</strong> e <strong>rendere visibili i malfunzionamenti</strong>.</p>
                <aside class="notes">
                    È importante distinguere questi due termini. Il malfunzionamento è quello che l'utente vede (es. l'app crasha, un calcolo è sbagliato). Questo è il sintomo.
                    Il difetto è la riga di codice sbagliata, il requisito frainteso, l'errore logico che *causa* quel sintomo.
                    Il nostro lavoro nel testing è trovare le condizioni (input, sequenza di azioni) che scatenano il difetto, così da poterlo poi correggere.
                </aside>
            </section>

            <section>
                <h2>Fasi e Pianificazione del Collaudo</h2>
                <p class="fragment fade-up">Fasi comuni:</p>
                <ul>
                    <li class="fragment fade-left"><strong>Alpha test:</strong> Test <em>interni</em> (sviluppatori, team QA).</li>
                    <li class="fragment fade-left"><strong>Beta test:</strong> Test <em>esterni</em> (utenti selezionati) in ambiente reale.</li>
                </ul>
                <p class="fragment fade-up"><strong>Piano di Collaudo:</strong> Documento formale con:</p>
                <ul>
                    <li class="fragment fade-right"><strong>Check list / Test Case:</strong> Elenco prove (input, passi, output attesi).</li>
                    <li class="fragment fade-right"><strong>Scenari di Collaudo:</strong> Flussi di utilizzo realistici da verificare.</li>
                </ul>
                <aside class="notes">
                    Il collaudo non è improvvisato. Segue delle fasi. L'Alpha test è fatto "in casa", per una prima verifica approfondita. Il Beta test coinvolge utenti reali, per scoprire problemi in condizioni d'uso quotidiane.
                    Tutto questo è guidato da un Piano di Collaudo. Questo documento definisce cosa testare, come, chi lo fa, e quali strumenti usare. Include Test Case dettagliati (ogni singola prova) e Scenari (che mettono insieme più passi, simulando un'attività utente completa).
                </aside>
            </section>

            <section>
                <h2>Tipi Principali di Test: <strong>Funzionali</strong></h2>
                <p class="fragment fade-in">Verificano <strong>COSA</strong> fa il software rispetto ai requisiti.</p>
                <ul>
                    <li class="fragment fade-up"><strong>Black-box:</strong> Basati su specifiche (input/output), <em>senza</em> vedere il codice.
                        <ul class="smaller-text"><li>Come l'utente interagisce.</li></ul>
                    </li>
                    <li class="fragment fade-up"><strong>White-box:</strong> Basati sul codice sorgente (percorsi logici), <em>conoscendo</em> l'implementazione.
                        <ul class="smaller-text"><li>Verifica della struttura interna.</li></ul>
                    </li>
                </ul>
                 <p class="fragment fade-in"><strong>Granularità:</strong> Modulo/Unità (White) -> Integrazione -> Sistema (Black) -> Accettazione.</p>
                 <aside class="notes">
                    Ci sono diversi tipi di test. I Funzionali controllano che il software faccia quello per cui è stato progettato.
                    Possiamo farlo in due modi principali:
                    Black-box: come un utente, non ci interessa come è fatto dentro, solo che l'input dia l'output atteso. Ottimo per testare i requisiti.
                    White-box: guardiamo dentro il codice, per assicurarci che tutte le logiche interne siano state eseguite e funzionino. Tipico dei test unitari fatti dagli sviluppatori.
                    I test procedono per livelli: prima le piccole parti (unità), poi come interagiscono (integrazione), poi il sistema completo, e infine l'accettazione da parte dell'utente.
                </aside>
            </section>

            <section>
                 <h2>Tipi Principali di Test: <strong>Prestazionali</strong></h2>
                 <p class="fragment fade-in">Verificano <strong>COME</strong> si comporta il software (velocità, carico, stabilità).</p>
                 <ul>
                     <li class="fragment fade-left"><strong>Performance:</strong> Tempi di risposta sotto carico normale.</li>
                     <li class="fragment fade-left"><strong>Carico (Load):</strong> Reazione all'aumento del carico (utenti, dati).</li>
                     <li class="fragment fade-left"><strong>Durata (Soak):</strong> Stabilità nel tempo (es. memory leak?).</li>
                     <li class="fragment fade-left"><strong>Stress:</strong> Comportamento sotto condizioni estreme (fino al limite).</li>
                 </ul>
                 <aside class="notes">
                    Oltre a *cosa* fa il software, ci interessa *come* lo fa. I test prestazionali (o non funzionali) verificano questo.
                    Performance: è abbastanza veloce nell'uso normale?
                    Carico: cosa succede se arrivano 100, 1000, 10000 utenti contemporaneamente? Regge?
                    Durata: se lo lascio acceso per 24 ore sotto carico, consuma sempre più memoria o rimane stabile?
                    Stress: cosa succede se gli tolgo la rete, o se il disco è pieno? Si rompe in modo controllato o va in crash totale?
                    Questi test sono cruciali per garantire una buona esperienza utente e l'affidabilità del sistema.
                </aside>
            </section>

            <section data-transition="zoom-in fade-out">
                 <h2>19.5 Valutazione e Stima - <strong>Metriche Software</strong></h2>
                 <p class="fragment fade-up"><strong>Definizione:</strong> Misure quantitative standard per proprietà del software o del processo.</p>
                 <p class="fragment fade-up">Usi principali:</p>
                 <ul>
                     <li class="fragment fade-right">Stima <strong>budget</strong> e <strong>effort</strong> (lavoro).</li>
                     <li class="fragment fade-right">Valutazione <strong>produttività</strong>.</li>
                     <li class="fragment fade-right">Misura e controllo <strong>qualità</strong>.</li>
                 </ul>
                 <p class="fragment grow"><strong>Attenzione:</strong> Forniscono <strong>stime</strong> e indicatori, non certezze assolute!</p>
                 <p class="fragment fade-up">Importanti anche le metriche di <strong>processo</strong> (es. bug trovati/risolti).</p>
                 <aside class="notes">
                    Passiamo ora alle metriche. Come misuriamo il software e il processo per crearlo?
                    Le metriche sono standard per dare numeri a concetti come 'dimensione', 'complessità', 'qualità'.
                    Ci servono per pianificare (Quanto costerà? Quanto ci vorrà?), per vedere se stiamo lavorando bene (produttività), e per tenere sotto controllo la qualità (Quanti bug stiamo trovando?).
                    Ma attenzione! Le metriche sono utili indicatori, ma raramente danno risposte esatte. Vanno interpretate con intelligenza e contesto.
                    Non misuriamo solo il prodotto finale, ma anche come ci arriviamo (il processo).
                 </aside>
            </section>

            <section>
                <h2>Metrica Comune: <strong>SLOC</strong> (Source Lines Of Code)</h2>
                <p class="fragment fade-in">Conta le <strong>linee di codice</strong> sorgente.</p>
                <p class="fragment fade-in">Idea base (semplice, ma limitata): <strong>Più linee = Più complessità/effort (?)</strong></p>
                <ul>
                    <li class="fragment fade-left"><strong>Physical SLOC:</strong> Righe fisiche (incl. commenti/vuote, con regole).</li>
                    <li class="fragment fade-left"><strong>Logical SLOC:</strong> Istruzioni effettive (es. ';' in C/Java).</li>
                </ul>
                 <pre class="fragment grow"><code class="language-c" data-trim data-noescape>
                 for(i=0; i&lt;100; ++i) printf("hello"); /* Istruz. 1 & 2 */
                 </code></pre>
                 <p class="fragment fade-up smaller-text">Esempio: 1 Physical SLOC, 2 Logical SLOC.</p>
                 <aside class="notes">
                    Una delle metriche più vecchie e semplici è la SLOC: contiamo le linee di codice.
                    L'idea intuitiva è che più codice c'è, più è costato farlo e più è complesso. Ma è un'idea molto grezza.
                    Distinguiamo tra linee fisiche (tutto quello che c'è nel file) e linee logiche (le istruzioni vere e proprie).
                    Guardate l'esempio: una riga fisica contiene due istruzioni logiche in C.
                    Il GRANDE limite delle SLOC? Dipende tantissimo dal linguaggio (100 righe di Assembly vs 100 righe di Python), dallo stile di chi scrive, e non dice nulla sulla funzionalità reale o sulla qualità! Utile forse per confronti *molto* specifici, ma pericolosa se usata come misura universale di produttività o complessità.
                 </aside>
            </section>

            <section>
                <h2>Metrica Comune: <strong>Complessità Ciclomatica</strong> (McCabe)</h2>
                <p class="fragment fade-in">Misura la complessità <strong>strutturale</strong> (nodi decisionali nel codice).</p>
                <p class="fragment fade-in">Indica il numero di <strong>percorsi indipendenti</strong> nel flusso di controllo.</p>
                 <p class="fragment grow">Formula: $V(G) = E - N + 2P$ (o più semplicemente: N. Decisioni + 1)</p>
                <p class="fragment fade-up"><strong>Utilità:</strong></p>
                <ul>
                    <li class="fragment fade-left">Stima la difficoltà di <strong>comprensione</strong> e <strong>manutenzione</strong>.</li>
                    <li class="fragment fade-left">Guida il <strong>testing white-box</strong> (numero minimo di test per copertura).</li>
                 </ul>
                 <aside class="notes">
                    Questa metrica è più sofisticata. La Complessità Ciclomatica, inventata da McCabe, misura quanti "bivi" logici ci sono in una funzione o modulo (if, while, for, switch...).
                    Più alto è il numero, più percorsi diversi ci sono nel codice.
                    Un valore alto significa che il codice è probabilmente più difficile da capire, da modificare senza fare danni, e da testare a fondo.
                    Infatti, questo numero ci dà un'idea di quanti test case servono almeno per provare ogni "ramo" logico del codice (branch coverage). Valori sopra 10-15 iniziano a essere un campanello d'allarme.
                 </aside>
            </section>

            <section>
                <h2>Metrica Comune: <strong>Function Point (FP)</strong> Analysis</h2>
                <p class="fragment fade-in">Misura la <strong>dimensione funzionale</strong> percepita dall'utente.</p>
                <p class="fragment fade-in">Si basa sulle <strong>funzionalità</strong> offerte, non sul codice.</p>
                <p class="fragment grow"><strong>Vantaggio Chiave:</strong> INDIPENDENTE dalla tecnologia!</p>
                <ul>
                    <li class="fragment fade-up">Misura cosa il software <strong>fa</strong> per l'utente.</li>
                    <li class="fragment fade-up">Permette confronti tra progetti diversi.</li>
                </ul>
                <p class="fragment fade-up smaller-text">Standardizzato (es. IFPUG, ISO/IEC 14143-1).</p>
                <aside class="notes">
                    I Function Point cambiano prospettiva. Invece di guardare il codice (come SLOC) o la sua struttura (come McCabe), guardano COSA il software fa per l'utente.
                    Misurano le "funzioni" consegnate: quanti tipi di dati in input gestisce? Quanti report produce? Quante interrogazioni permette?
                    Il grande vantaggio è che sono indipendenti da linguaggio, piattaforma, o stile di programmazione. Posso confrontare un sistema Cobol con uno Java in termini di funzionalità offerte.
                    Questo li rende molto utili per stime precoci e per misurare la produttività in modo più oggettivo. Esistono standard internazionali per contarli.
                 </aside>
            </section>

            <section>
                <h2>Function Point (FP): Caratteristiche e <strong>Benefici</strong></h2>
                <ul>
                    <li class="fragment fade-left">Basato sui <strong>requisiti utente</strong> (logici).</li>
                    <li class="fragment fade-left">Applicabile <strong>presto</strong> nel ciclo di vita (dall'analisi).</li>
                    <li class="fragment fade-left">Indipendente da aspetti tecnici e non funzionali.</li>
                </ul>
                 <p class="fragment fade-up"><strong>Benefici Principali:</strong></p>
                 <ul>
                    <li class="fragment fade-right">Migliora <strong>comprensione requisiti</strong>.</li>
                    <li class="fragment fade-right">Migliora <strong>stime</strong> (effort, costi, tempi - con dati storici).</li>
                    <li class="fragment fade-right">Supporta pianificazione <strong>test di accettazione</strong>.</li>
                </ul>
                <aside class="notes">
                    Ricapitoliamo i punti di forza dei Function Point:
                    Si basano sui requisiti, quindi costringono ad analizzarli bene.
                    Si possono calcolare già dalla fase di analisi, quando non c'è ancora codice, permettendo stime anticipate.
                    Sono "puri": misurano solo la funzionalità, non la qualità, non la tecnologia, non quanto è stato difficile farla.
                    Questo porta a benefici concreti: capiamo meglio cosa vuole l'utente, le nostre stime diventano più affidabili (se abbiamo dati storici di quanti FP facciamo all'ora o quanto costa un FP), e ci aiuta a definire cosa deve essere testato per l'accettazione finale.
                    Il conteggio richiede un metodo preciso (basato su tipi di funzioni come Input, Output, Interrogazioni, File Interni, File Esterni) e spesso una certificazione.
                </aside>
            </section>

            <section>
                <h2>Altre Metriche Rilevanti</h2>
                <ul>
                    <li class="fragment fade-up"><strong>Densità dei Difetti:</strong> Errori / Dimensione (KSLOC o FP) -> Indicatore qualità.</li>
                    <li class="fragment fade-up"><strong>Code Coverage:</strong> % codice eseguito dai test -> Efficacia suite test.</li>
                    <li class="fragment fade-up"><strong>Conteggio Requisiti:</strong> Tracciamento progresso / completezza.</li>
                    <li class="fragment fade-up"><strong>Metriche OO (Chidamber & Kemerer):</strong> Specifiche per oggetti (coupling, ereditarietà...).</li>
                    <li class="fragment fade-up"><strong>MTBF (Mean Time Between Failures):</strong> Tempo medio tra guasti -> Affidabilità operativa.</li>
                </ul>
                <aside class="notes">
                    Oltre a SLOC, Complessità e FP, esistono molte altre metriche utili:
                    Densità Difetti: quanti bug troviamo per ogni "unità" di software? Un indicatore diretto della qualità.
                    Code Coverage: i nostri test automatici quanto codice stanno effettivamente eseguendo? Se è bassa, abbiamo zone non testate.
                    Conteggio Requisiti: semplice ma utile per vedere a che punto siamo.
                    Metriche per Oggetti: se usiamo linguaggi OO, ci sono metriche specifiche per misurare l'accoppiamento tra classi, la profondità dell'ereditarietà, ecc.
                    MTBF: per sistemi già in funzione, misura quanto tempo passa in media tra un guasto e l'altro. Un classico indicatore di affidabilità.
                    La scelta delle metriche giuste dipende dagli obiettivi che abbiamo.
                </aside>
            </section>

            <section data-transition="concave">
                <h2>Conclusioni Chiave</h2>
                <ul>
                    <li class="fragment grow"><strong>Testing</strong> e <strong>Metriche</strong> = Pilastri per progetti software di <strong>successo</strong>.</li>
                    <li class="fragment grow">Collaudo sistematico e integrato -> <strong>Migliora qualità</strong>, riduce rischi.</li>
                    <li class="fragment grow">Metriche quantitative -> Base per <strong>comprendere, stimare, controllare</strong>.</li>
                    <li class="fragment grow">Combinare metriche di <strong>prodotto</strong> e di <strong>processo</strong> -> Visione completa.</li>
                </ul>
                <aside class="notes">
                    In conclusione, abbiamo visto come Testing e Metriche siano fondamentali. Non sono attività secondarie, ma parti integranti di un processo di sviluppo professionale.
                    Testare bene e in modo continuo ci aiuta a costruire software migliore e a ridurre i costi nascosti dei bug scoperti tardi.
                    Usare le metriche con intelligenza ci permette di passare da opinioni soggettive a dati oggettivi per prendere decisioni informate su stime, qualità e gestione del progetto.
                    La strategia migliore è usare un mix di metriche: alcune che misurano il software stesso (prodotto) e altre che misurano come lo stiamo costruendo (processo). Questo ci dà la visione più completa e utile. Grazie per l'attenzione.
                </aside>
            </section>

        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/notes/notes.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/markdown/markdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/math/math.min.js"></script>

    <script>
        // Configurazione Reveal.js
        Reveal.initialize({
            hash: true,
            history: true,
            controls: true,
            progress: true,
            center: true,
            slideNumber: 'c/t',

            // Transizione di default (usata se non specificato sulla slide)
            transition: 'slide', // Semplice e veloce
            transitionSpeed: 'default',
            backgroundTransition: 'fade',

            // Abilita i plugin
            plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
        });

        // Info per l'utente su come usare le note
        console.log("Premi 'S' sulla tastiera per aprire la vista Speaker Notes in una nuova finestra.");
    </script>
</body>
</html>
